procedure Bool.1 ():
    let Bool.32 : Int1 = false;
    ret Bool.32;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.28 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.28;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.29 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.29;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.30 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.30;

procedure Bool.12 (#Attr.2, #Attr.3):
    let Bool.24 : Int1 = lowlevel NotEq #Attr.2 #Attr.3;
    ret Bool.24;

procedure Bool.12 (#Attr.2, #Attr.3):
    let Bool.26 : Int1 = lowlevel NotEq #Attr.2 #Attr.3;
    ret Bool.26;

procedure Bool.2 ():
    let Bool.31 : Int1 = true;
    ret Bool.31;

procedure Bool.7 (Bool.19, Bool.20):
    let Bool.25 : Int1 = CallByName Bool.12 Bool.19 Bool.20;
    ret Bool.25;

procedure Bool.7 (Bool.19, Bool.20):
    let Bool.27 : Int1 = CallByName Bool.12 Bool.19 Bool.20;
    ret Bool.27;

procedure Dict.1 (Dict.730):
    let Dict.892 : List {U32, U32} = Array [];
    let Dict.893 : List {Str, I64} = Array [];
    let Dict.894 : U64 = 0i64;
    let Dict.51 : Float32 = CallByName Dict.51;
    let Dict.52 : U8 = CallByName Dict.52;
    let Dict.891 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.892, Dict.893, Dict.894, Dict.51, Dict.52};
    ret Dict.891;

procedure Dict.10 (Dict.731, Dict.186, Dict.187):
    let Dict.185 : List {Str, I64} = StructAtIndex 1 Dict.731;
    let #Derived_gen.67 : List {U32, U32} = StructAtIndex 0 Dict.731;
    dec #Derived_gen.67;
    let Dict.1108 : {Str, Int1} = CallByName List.18 Dict.185 Dict.186 Dict.187;
    dec Dict.185;
    ret Dict.1108;

procedure Dict.100 (Dict.544, Dict.545, Dict.546):
    let Dict.1061 : U8 = CallByName Dict.22 Dict.544 Dict.545;
    let Dict.547 : U64 = CallByName Num.133 Dict.1061;
    let Dict.1060 : U8 = 1i64;
    let Dict.1059 : U64 = CallByName Num.74 Dict.546 Dict.1060;
    let Dict.1058 : U64 = CallByName Num.51 Dict.1059 Dict.545;
    let Dict.1057 : U8 = CallByName Dict.22 Dict.544 Dict.1058;
    let Dict.548 : U64 = CallByName Num.133 Dict.1057;
    let Dict.1056 : U64 = 1i64;
    let Dict.1055 : U64 = CallByName Num.75 Dict.546 Dict.1056;
    let Dict.1054 : U64 = CallByName Num.51 Dict.1055 Dict.545;
    let Dict.1053 : U8 = CallByName Dict.22 Dict.544 Dict.1054;
    let Dict.549 : U64 = CallByName Num.133 Dict.1053;
    let Dict.1052 : U8 = 16i64;
    let Dict.1049 : U64 = CallByName Num.72 Dict.547 Dict.1052;
    let Dict.1051 : U8 = 8i64;
    let Dict.1050 : U64 = CallByName Num.72 Dict.548 Dict.1051;
    let Dict.550 : U64 = CallByName Num.71 Dict.1049 Dict.1050;
    let Dict.1048 : U64 = CallByName Num.71 Dict.550 Dict.549;
    ret Dict.1048;

procedure Dict.12 (Dict.158):
    let Dict.890 : {} = Struct {};
    let Dict.738 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.1 Dict.890;
    let Dict.739 : {} = Struct {};
    let Dict.737 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName List.18 Dict.158 Dict.738 Dict.739;
    ret Dict.737;

procedure Dict.127 (Dict.128, Dict.126):
    let Dict.1105 : {} = Struct {};
    let Dict.1106 : {} = Struct {};
    let Dict.1107 : {} = Struct {};
    let Dict.1104 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = CallByName Inspect.42 Dict.126 Dict.1105 Dict.1106 Dict.1107;
    let Dict.1103 : Str = CallByName Inspect.31 Dict.1104 Dict.128;
    ret Dict.1103;

procedure Dict.159 (Dict.160, Dict.740):
    let Dict.161 : Str = StructAtIndex 0 Dict.740;
    let Dict.162 : I64 = StructAtIndex 1 Dict.740;
    let Dict.741 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.8 Dict.160 Dict.161 Dict.162;
    ret Dict.741;

procedure Dict.188 (Dict.189, Dict.1110, Dict.187):
    let Dict.190 : Str = StructAtIndex 0 Dict.1110;
    let Dict.191 : I64 = StructAtIndex 1 Dict.1110;
    let Dict.1112 : {Str, Int1} = CallByName Inspect.191 Dict.189 Dict.190 Dict.191 Dict.187;
    ret Dict.1112;

procedure Dict.20 (Dict.727):
    let Dict.155 : U64 = StructAtIndex 2 Dict.727;
    let #Derived_gen.70 : List {U32, U32} = StructAtIndex 0 Dict.727;
    dec #Derived_gen.70;
    let #Derived_gen.69 : List {Str, I64} = StructAtIndex 1 Dict.727;
    dec #Derived_gen.69;
    ret Dict.155;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.772 : {U32, U32} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.772;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.788 : {Str, I64} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.788;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.951 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.951;

procedure Dict.23 (#Attr.2):
    let Dict.824 : U64 = lowlevel DictPseudoSeed #Attr.2;
    ret Dict.824;

procedure Dict.4 (Dict.736):
    let Dict.163 : List {Str, I64} = StructAtIndex 1 Dict.736;
    let #Derived_gen.66 : List {U32, U32} = StructAtIndex 0 Dict.736;
    dec #Derived_gen.66;
    let Dict.889 : U64 = CallByName List.6 Dict.163;
    dec Dict.163;
    ret Dict.889;

procedure Dict.405 (Dict.406, Dict.847, Dict.408, Dict.404):
    let Dict.407 : Str = StructAtIndex 0 Dict.847;
    let Dict.852 : {U64, U32} = CallByName Dict.72 Dict.406 Dict.407 Dict.404;
    let Dict.409 : U64 = StructAtIndex 0 Dict.852;
    let Dict.410 : U32 = StructAtIndex 1 Dict.852;
    let Dict.851 : U32 = CallByName Num.131 Dict.408;
    let Dict.850 : {U32, U32} = Struct {Dict.851, Dict.410};
    let Dict.849 : List {U32, U32} = CallByName Dict.74 Dict.406 Dict.850 Dict.409;
    ret Dict.849;

procedure Dict.43 (Dict.126):
    let Dict.1100 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Inspect.30 Dict.126;
    ret Dict.1100;

procedure Dict.45 (#Derived_gen.42, #Derived_gen.43, #Derived_gen.44, #Derived_gen.45, #Derived_gen.46, #Derived_gen.47, #Derived_gen.48, #Derived_gen.49, #Derived_gen.50):
    joinpoint Dict.743 Dict.228 Dict.229 Dict.230 Dict.231 Dict.232 Dict.233 Dict.234 Dict.235 Dict.236:
        let Dict.237 : {U32, U32} = CallByName Dict.22 Dict.228 Dict.230;
        let Dict.790 : U32 = StructAtIndex 1 Dict.237;
        let Dict.778 : Int1 = CallByName Bool.11 Dict.231 Dict.790;
        if Dict.778 then
            let Dict.789 : U32 = StructAtIndex 0 Dict.237;
            let Dict.787 : U64 = CallByName Num.133 Dict.789;
            let Dict.786 : {Str, I64} = CallByName Dict.22 Dict.229 Dict.787;
            let Dict.238 : Str = StructAtIndex 0 Dict.786;
            let Dict.781 : Int1 = CallByName Bool.11 Dict.238 Dict.232;
            if Dict.781 then
                let Dict.785 : U32 = StructAtIndex 0 Dict.237;
                let Dict.783 : U64 = CallByName Num.133 Dict.785;
                let Dict.784 : {Str, I64} = Struct {Dict.232, Dict.233};
                let Dict.239 : List {Str, I64} = CallByName List.3 Dict.229 Dict.783 Dict.784;
                let Dict.782 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.228, Dict.239, Dict.234, Dict.235, Dict.236};
                ret Dict.782;
            else
                let Dict.780 : U64 = CallByName List.6 Dict.228;
                let Dict.240 : U64 = CallByName Dict.75 Dict.230 Dict.780;
                let Dict.241 : U32 = CallByName Dict.55 Dict.231;
                jump Dict.743 Dict.228 Dict.229 Dict.240 Dict.241 Dict.232 Dict.233 Dict.234 Dict.235 Dict.236;
        else
            let Dict.777 : U32 = StructAtIndex 1 Dict.237;
            let Dict.757 : Int1 = CallByName Num.24 Dict.231 Dict.777;
            if Dict.757 then
                let Dict.776 : {Str, I64} = Struct {Dict.232, Dict.233};
                let Dict.242 : List {Str, I64} = CallByName List.4 Dict.229 Dict.776;
                let Dict.774 : U64 = CallByName List.6 Dict.242;
                let Dict.775 : U64 = 1i64;
                let Dict.243 : U64 = CallByName Num.75 Dict.774 Dict.775;
                let Dict.773 : U32 = CallByName Num.131 Dict.243;
                let Dict.759 : {U32, U32} = Struct {Dict.773, Dict.231};
                let Dict.244 : List {U32, U32} = CallByName Dict.74 Dict.228 Dict.759 Dict.230;
                let Dict.758 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.244, Dict.242, Dict.234, Dict.235, Dict.236};
                ret Dict.758;
            else
                let Dict.750 : U64 = CallByName List.6 Dict.228;
                let Dict.245 : U64 = CallByName Dict.75 Dict.230 Dict.750;
                let Dict.246 : U32 = CallByName Dict.55 Dict.231;
                jump Dict.743 Dict.228 Dict.229 Dict.245 Dict.246 Dict.232 Dict.233 Dict.234 Dict.235 Dict.236;
    in
    inc #Derived_gen.46;
    jump Dict.743 #Derived_gen.42 #Derived_gen.43 #Derived_gen.44 #Derived_gen.45 #Derived_gen.46 #Derived_gen.47 #Derived_gen.48 #Derived_gen.49 #Derived_gen.50;

procedure Dict.48 ():
    let Dict.867 : U32 = 0i64;
    let Dict.868 : U32 = 0i64;
    let Dict.866 : {U32, U32} = Struct {Dict.867, Dict.868};
    ret Dict.866;

procedure Dict.49 ():
    let Dict.748 : U32 = 1i64;
    let Dict.749 : U8 = 8i64;
    let Dict.747 : U32 = CallByName Num.72 Dict.748 Dict.749;
    ret Dict.747;

procedure Dict.50 ():
    let Dict.798 : U32 = CallByName Dict.49;
    let Dict.799 : U32 = 1i64;
    let Dict.797 : U32 = CallByName Num.75 Dict.798 Dict.799;
    ret Dict.797;

procedure Dict.51 ():
    let Dict.898 : Float32 = 0.8f64;
    ret Dict.898;

procedure Dict.52 ():
    let Dict.896 : U8 = 64i64;
    let Dict.897 : U8 = 3i64;
    let Dict.895 : U8 = CallByName Num.75 Dict.896 Dict.897;
    ret Dict.895;

procedure Dict.53 ():
    let Dict.841 : U64 = 1i64;
    let Dict.842 : U8 = 32i64;
    let Dict.840 : U64 = CallByName Num.72 Dict.841 Dict.842;
    ret Dict.840;

procedure Dict.54 ():
    let Dict.839 : U64 = CallByName Dict.53;
    ret Dict.839;

procedure Dict.55 (Dict.313):
    let Dict.746 : U32 = CallByName Dict.49;
    let Dict.745 : U32 = CallByName Num.51 Dict.313 Dict.746;
    ret Dict.745;

procedure Dict.66 (Dict.726):
    let Dict.383 : List {Str, I64} = StructAtIndex 1 Dict.726;
    let Dict.384 : U64 = StructAtIndex 2 Dict.726;
    let Dict.385 : Float32 = StructAtIndex 3 Dict.726;
    let Dict.386 : U8 = StructAtIndex 4 Dict.726;
    let #Derived_gen.68 : List {U32, U32} = StructAtIndex 0 Dict.726;
    dec #Derived_gen.68;
    let Dict.884 : U64 = CallByName Dict.54;
    let Dict.843 : Int1 = CallByName Bool.7 Dict.384 Dict.884;
    if Dict.843 then
        let Dict.883 : U8 = 1i64;
        let Dict.387 : U8 = CallByName Num.75 Dict.386 Dict.883;
        let Dict.862 : {List {U32, U32}, U64} = CallByName Dict.67 Dict.387 Dict.385;
        let Dict.388 : List {U32, U32} = StructAtIndex 0 Dict.862;
        let Dict.389 : U64 = StructAtIndex 1 Dict.862;
        let Dict.390 : List {U32, U32} = CallByName Dict.71 Dict.388 Dict.383 Dict.387;
        let Dict.844 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.390, Dict.383, Dict.389, Dict.385, Dict.387};
        ret Dict.844;
    else
        dec Dict.383;
        let Dict.834 : Str = "Dict hit limit of ";
        let Dict.838 : U64 = CallByName Dict.54;
        let Dict.836 : Str = CallByName Num.96 Dict.838;
        let Dict.837 : Str = " elements. Unable to grow more.";
        let Dict.835 : Str = CallByName Str.3 Dict.836 Dict.837;
        dec Dict.837;
        let Dict.833 : Str = CallByName Str.3 Dict.834 Dict.835;
        dec Dict.835;
        Crash Dict.833

procedure Dict.67 (Dict.391, Dict.392):
    let Dict.393 : U64 = CallByName Dict.70 Dict.391;
    let Dict.876 : U64 = CallByName Dict.54;
    let Dict.871 : Int1 = CallByName Bool.11 Dict.393 Dict.876;
    if Dict.871 then
        let Dict.874 : {U32, U32} = CallByName Dict.48;
        let Dict.875 : U64 = CallByName Dict.54;
        let Dict.873 : List {U32, U32} = CallByName List.11 Dict.874 Dict.875;
        let Dict.54 : U64 = CallByName Dict.54;
        let Dict.872 : {List {U32, U32}, U64} = Struct {Dict.873, Dict.54};
        ret Dict.872;
    else
        let Dict.870 : Float32 = CallByName Num.139 Dict.393;
        let Dict.869 : Float32 = CallByName Num.21 Dict.870 Dict.392;
        let Dict.394 : U64 = CallByName Num.50 Dict.869;
        let Dict.865 : {U32, U32} = CallByName Dict.48;
        let Dict.864 : List {U32, U32} = CallByName List.11 Dict.865 Dict.393;
        let Dict.863 : {List {U32, U32}, U64} = Struct {Dict.864, Dict.394};
        ret Dict.863;

procedure Dict.70 (Dict.401):
    let Dict.880 : U64 = 1i64;
    let Dict.882 : U8 = 64i64;
    let Dict.881 : U8 = CallByName Num.75 Dict.882 Dict.401;
    let Dict.878 : U64 = CallByName Num.72 Dict.880 Dict.881;
    let Dict.879 : U64 = CallByName Dict.54;
    let Dict.877 : U64 = CallByName Num.148 Dict.878 Dict.879;
    ret Dict.877;

procedure Dict.71 (Dict.402, Dict.403, Dict.404):
    let Dict.845 : List {U32, U32} = CallByName List.83 Dict.403 Dict.402 Dict.404;
    ret Dict.845;

procedure Dict.72 (Dict.411, Dict.412, Dict.413):
    let Dict.414 : U64 = CallByName Dict.76 Dict.412;
    let Dict.415 : U32 = CallByName Dict.77 Dict.414;
    let Dict.416 : U64 = CallByName Dict.78 Dict.414 Dict.413;
    let Dict.853 : {U64, U32} = CallByName Dict.73 Dict.411 Dict.416 Dict.415;
    ret Dict.853;

procedure Dict.73 (#Derived_gen.16, #Derived_gen.17, #Derived_gen.18):
    joinpoint Dict.854 Dict.417 Dict.418 Dict.419:
        let Dict.420 : {U32, U32} = CallByName Dict.22 Dict.417 Dict.418;
        let Dict.861 : U32 = StructAtIndex 1 Dict.420;
        let Dict.856 : Int1 = CallByName Num.22 Dict.419 Dict.861;
        if Dict.856 then
            let Dict.860 : U64 = CallByName List.6 Dict.417;
            let Dict.858 : U64 = CallByName Dict.75 Dict.418 Dict.860;
            let Dict.859 : U32 = CallByName Dict.55 Dict.419;
            jump Dict.854 Dict.417 Dict.858 Dict.859;
        else
            dec Dict.417;
            let Dict.855 : {U64, U32} = Struct {Dict.418, Dict.419};
            ret Dict.855;
    in
    inc #Derived_gen.16;
    jump Dict.854 #Derived_gen.16 #Derived_gen.17 #Derived_gen.18;

procedure Dict.74 (#Derived_gen.51, #Derived_gen.52, #Derived_gen.53):
    joinpoint Dict.760 Dict.421 Dict.422 Dict.423:
        let Dict.424 : {U32, U32} = CallByName Dict.22 Dict.421 Dict.423;
        let Dict.770 : U32 = StructAtIndex 1 Dict.424;
        let Dict.771 : U32 = 0i64;
        let Dict.762 : Int1 = CallByName Bool.7 Dict.770 Dict.771;
        if Dict.762 then
            let Dict.425 : List {U32, U32} = CallByName List.3 Dict.421 Dict.423 Dict.422;
            let Dict.767 : U32 = StructAtIndex 0 Dict.424;
            let Dict.768 : U32 = StructAtIndex 1 Dict.424;
            let Dict.769 : U32 = CallByName Dict.55 Dict.768;
            let Dict.764 : {U32, U32} = Struct {Dict.767, Dict.769};
            let Dict.766 : U64 = CallByName List.6 Dict.425;
            let Dict.765 : U64 = CallByName Dict.75 Dict.423 Dict.766;
            jump Dict.760 Dict.425 Dict.764 Dict.765;
        else
            let Dict.761 : List {U32, U32} = CallByName List.3 Dict.421 Dict.423 Dict.422;
            ret Dict.761;
    in
    jump Dict.760 #Derived_gen.51 #Derived_gen.52 #Derived_gen.53;

procedure Dict.75 (Dict.426, Dict.427):
    let Dict.756 : U64 = 1i64;
    let Dict.755 : U64 = CallByName Num.51 Dict.426 Dict.756;
    let Dict.752 : Int1 = CallByName Bool.7 Dict.755 Dict.427;
    if Dict.752 then
        let Dict.754 : U64 = 1i64;
        let Dict.753 : U64 = CallByName Num.51 Dict.426 Dict.754;
        ret Dict.753;
    else
        let Dict.751 : U64 = 0i64;
        ret Dict.751;

procedure Dict.76 (Dict.428):
    let Dict.804 : [C , C U64] = TagId(0) ;
    let Dict.803 : {U64, U64} = CallByName Dict.80 Dict.804;
    let Dict.801 : {U64, U64} = CallByName Hash.19 Dict.803 Dict.428;
    let Dict.800 : U64 = CallByName Dict.83 Dict.801;
    ret Dict.800;

procedure Dict.77 (Dict.430):
    let Dict.795 : U32 = CallByName Num.131 Dict.430;
    let Dict.796 : U32 = CallByName Dict.50;
    let Dict.793 : U32 = CallByName Num.69 Dict.795 Dict.796;
    let Dict.794 : U32 = CallByName Dict.49;
    let Dict.792 : U32 = CallByName Num.71 Dict.793 Dict.794;
    ret Dict.792;

procedure Dict.78 (Dict.431, Dict.432):
    let Dict.791 : U64 = CallByName Num.74 Dict.431 Dict.432;
    ret Dict.791;

procedure Dict.8 (Dict.217, Dict.218, Dict.219):
    joinpoint Dict.831 Dict.829:
        let Dict.220 : List {U32, U32} = StructAtIndex 0 Dict.829;
        let Dict.221 : List {Str, I64} = StructAtIndex 1 Dict.829;
        let Dict.222 : U64 = StructAtIndex 2 Dict.829;
        let Dict.223 : Float32 = StructAtIndex 3 Dict.829;
        let Dict.224 : U8 = StructAtIndex 4 Dict.829;
        inc Dict.218;
        let Dict.225 : U64 = CallByName Dict.76 Dict.218;
        let Dict.226 : U32 = CallByName Dict.77 Dict.225;
        let Dict.227 : U64 = CallByName Dict.78 Dict.225 Dict.224;
        let Dict.742 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.45 Dict.220 Dict.221 Dict.227 Dict.226 Dict.218 Dict.219 Dict.222 Dict.223 Dict.224;
        dec Dict.218;
        ret Dict.742;
    in
    inc 2 Dict.217;
    let Dict.886 : U64 = CallByName Dict.4 Dict.217;
    let Dict.887 : U64 = CallByName Dict.20 Dict.217;
    let Dict.885 : Int1 = CallByName Num.22 Dict.886 Dict.887;
    if Dict.885 then
        jump Dict.831 Dict.217;
    else
        let Dict.830 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.66 Dict.217;
        jump Dict.831 Dict.830;

procedure Dict.80 (Dict.434):
    joinpoint Dict.821 Dict.435:
        let Dict.806 : U64 = CallByName Dict.82 Dict.435;
        let Dict.805 : {U64, U64} = Struct {Dict.806, Dict.435};
        ret Dict.805;
    in
    let Dict.826 : U8 = 0i64;
    let Dict.827 : U8 = GetTagId Dict.434;
    let Dict.828 : Int1 = lowlevel Eq Dict.826 Dict.827;
    if Dict.828 then
        let Dict.823 : {} = Struct {};
        let Dict.822 : U64 = CallByName Dict.23 Dict.823;
        jump Dict.821 Dict.822;
    else
        let Dict.436 : U64 = UnionAtIndex (Id 1) (Index 0) Dict.434;
        jump Dict.821 Dict.436;

procedure Dict.81 (Dict.715, Dict.716):
    let Dict.439 : U64 = StructAtIndex 0 Dict.716;
    let Dict.440 : U64 = StructAtIndex 1 Dict.716;
    let Dict.442 : U64 = StructAtIndex 2 Dict.716;
    let Dict.441 : U64 = StructAtIndex 3 Dict.716;
    let Dict.437 : U64 = StructAtIndex 0 Dict.715;
    let Dict.438 : U64 = StructAtIndex 1 Dict.715;
    let Dict.920 : U64 = CallByName Dict.93;
    let Dict.918 : U64 = CallByName Num.70 Dict.439 Dict.920;
    let Dict.919 : U64 = CallByName Num.70 Dict.440 Dict.441;
    let Dict.443 : {U64, U64} = CallByName Dict.97 Dict.918 Dict.919;
    let Dict.915 : U64 = StructAtIndex 0 Dict.443;
    let Dict.916 : U64 = CallByName Dict.92;
    let Dict.914 : U64 = CallByName Num.70 Dict.915 Dict.916;
    let Dict.444 : U64 = CallByName Num.70 Dict.914 Dict.442;
    let Dict.911 : U64 = StructAtIndex 1 Dict.443;
    let Dict.912 : U64 = CallByName Dict.93;
    let Dict.445 : U64 = CallByName Num.70 Dict.911 Dict.912;
    let Dict.446 : U64 = CallByName Dict.96 Dict.444 Dict.445;
    let Dict.903 : U64 = CallByName Dict.96 Dict.438 Dict.446;
    let Dict.902 : {U64, U64} = Struct {Dict.437, Dict.903};
    ret Dict.902;

procedure Dict.82 (Dict.447):
    let Dict.819 : U64 = CallByName Dict.92;
    let Dict.809 : U64 = CallByName Num.70 Dict.447 Dict.819;
    let Dict.810 : U64 = CallByName Dict.93;
    let Dict.808 : U64 = CallByName Dict.96 Dict.809 Dict.810;
    let Dict.807 : U64 = CallByName Num.70 Dict.808 Dict.447;
    ret Dict.807;

procedure Dict.83 (Dict.734):
    let Dict.448 : U64 = StructAtIndex 1 Dict.734;
    ret Dict.448;

procedure Dict.89 (Dict.709, Dict.487):
    let Dict.485 : U64 = StructAtIndex 0 Dict.709;
    let Dict.486 : U64 = StructAtIndex 1 Dict.709;
    let Dict.488 : U64 = CallByName List.6 Dict.487;
    joinpoint Dict.925 Dict.489:
        let Dict.900 : {U64, U64} = Struct {Dict.485, Dict.486};
        let Dict.921 : U64 = StructAtIndex 0 Dict.489;
        let Dict.922 : U64 = StructAtIndex 1 Dict.489;
        let Dict.923 : U64 = StructAtIndex 2 Dict.489;
        let Dict.901 : {U64, U64, U64, U64} = Struct {Dict.921, Dict.922, Dict.488, Dict.923};
        let Dict.899 : {U64, U64} = CallByName Dict.81 Dict.900 Dict.901;
        ret Dict.899;
    in
    let Dict.1099 : U64 = 16i64;
    let Dict.1039 : Int1 = CallByName Num.23 Dict.488 Dict.1099;
    if Dict.1039 then
        joinpoint Dict.1041 Dict.924:
            jump Dict.925 Dict.924;
        in
        let Dict.1098 : U64 = 4i64;
        let Dict.1063 : Int1 = CallByName Num.25 Dict.488 Dict.1098;
        if Dict.1063 then
            let Dict.1097 : U8 = 3i64;
            let Dict.1095 : U64 = CallByName Num.74 Dict.488 Dict.1097;
            let Dict.1096 : U8 = 2i64;
            let Dict.490 : U64 = CallByName Num.72 Dict.1095 Dict.1096;
            let Dict.1094 : U64 = 0i64;
            let Dict.1092 : U64 = CallByName Dict.99 Dict.487 Dict.1094;
            let Dict.1093 : U8 = 32i64;
            let Dict.1090 : U64 = CallByName Num.72 Dict.1092 Dict.1093;
            let Dict.1091 : U64 = CallByName Dict.99 Dict.487 Dict.490;
            let Dict.491 : U64 = CallByName Num.71 Dict.1090 Dict.1091;
            let Dict.1089 : U64 = 4i64;
            let Dict.1088 : U64 = CallByName Num.75 Dict.488 Dict.1089;
            let Dict.1086 : U64 = CallByName Dict.99 Dict.487 Dict.1088;
            let Dict.1087 : U8 = 32i64;
            let Dict.1064 : U64 = CallByName Num.72 Dict.1086 Dict.1087;
            let Dict.1085 : U64 = 4i64;
            let Dict.1084 : U64 = CallByName Num.75 Dict.488 Dict.1085;
            let Dict.1066 : U64 = CallByName Num.75 Dict.1084 Dict.490;
            let Dict.1065 : U64 = CallByName Dict.99 Dict.487 Dict.1066;
            let Dict.492 : U64 = CallByName Num.71 Dict.1064 Dict.1065;
            let Dict.1040 : {U64, U64, U64} = Struct {Dict.491, Dict.492, Dict.485};
            jump Dict.1041 Dict.1040;
        else
            let Dict.1062 : U64 = 0i64;
            let Dict.1044 : Int1 = CallByName Num.24 Dict.488 Dict.1062;
            if Dict.1044 then
                let Dict.1047 : U64 = 0i64;
                let Dict.1045 : U64 = CallByName Dict.100 Dict.487 Dict.1047 Dict.488;
                let Dict.1046 : U64 = 0i64;
                let Dict.1040 : {U64, U64, U64} = Struct {Dict.1045, Dict.1046, Dict.485};
                jump Dict.1041 Dict.1040;
            else
                let Dict.1042 : U64 = 0i64;
                let Dict.1043 : U64 = 0i64;
                let Dict.1040 : {U64, U64, U64} = Struct {Dict.1042, Dict.1043, Dict.485};
                jump Dict.1041 Dict.1040;
    else
        let Dict.1038 : U64 = 48i64;
        let Dict.1036 : Int1 = CallByName Num.23 Dict.488 Dict.1038;
        if Dict.1036 then
            let Dict.1037 : U64 = 0i64;
            let Dict.924 : {U64, U64, U64} = CallByName Dict.91 Dict.485 Dict.487 Dict.1037 Dict.488;
            jump Dict.925 Dict.924;
        else
            let Dict.926 : U64 = 0i64;
            let Dict.924 : {U64, U64, U64} = CallByName Dict.90 Dict.485 Dict.485 Dict.485 Dict.487 Dict.926 Dict.488;
            jump Dict.925 Dict.924;

procedure Dict.90 (#Derived_gen.6, #Derived_gen.7, #Derived_gen.8, #Derived_gen.9, #Derived_gen.10, #Derived_gen.11):
    joinpoint Dict.927 Dict.493 Dict.494 Dict.495 Dict.496 Dict.497 Dict.498:
        let Dict.1034 : U64 = CallByName Dict.98 Dict.496 Dict.497;
        let Dict.1035 : U64 = CallByName Dict.93;
        let Dict.1029 : U64 = CallByName Num.70 Dict.1034 Dict.1035;
        let Dict.1033 : U64 = 8i64;
        let Dict.1032 : U64 = CallByName Num.51 Dict.497 Dict.1033;
        let Dict.1031 : U64 = CallByName Dict.98 Dict.496 Dict.1032;
        let Dict.1030 : U64 = CallByName Num.70 Dict.1031 Dict.493;
        let Dict.499 : U64 = CallByName Dict.96 Dict.1029 Dict.1030;
        let Dict.1028 : U64 = 16i64;
        let Dict.1027 : U64 = CallByName Num.51 Dict.497 Dict.1028;
        let Dict.1024 : U64 = CallByName Dict.98 Dict.496 Dict.1027;
        let Dict.1025 : U64 = CallByName Dict.94;
        let Dict.1019 : U64 = CallByName Num.70 Dict.1024 Dict.1025;
        let Dict.1023 : U64 = 24i64;
        let Dict.1022 : U64 = CallByName Num.51 Dict.497 Dict.1023;
        let Dict.1021 : U64 = CallByName Dict.98 Dict.496 Dict.1022;
        let Dict.1020 : U64 = CallByName Num.70 Dict.1021 Dict.494;
        let Dict.500 : U64 = CallByName Dict.96 Dict.1019 Dict.1020;
        let Dict.1018 : U64 = 32i64;
        let Dict.1017 : U64 = CallByName Num.51 Dict.497 Dict.1018;
        let Dict.1014 : U64 = CallByName Dict.98 Dict.496 Dict.1017;
        let Dict.1015 : U64 = CallByName Dict.95;
        let Dict.1009 : U64 = CallByName Num.70 Dict.1014 Dict.1015;
        let Dict.1013 : U64 = 40i64;
        let Dict.1012 : U64 = CallByName Num.51 Dict.497 Dict.1013;
        let Dict.1011 : U64 = CallByName Dict.98 Dict.496 Dict.1012;
        let Dict.1010 : U64 = CallByName Num.70 Dict.1011 Dict.495;
        let Dict.501 : U64 = CallByName Dict.96 Dict.1009 Dict.1010;
        let Dict.1008 : U64 = 48i64;
        let Dict.502 : U64 = CallByName Num.75 Dict.498 Dict.1008;
        let Dict.1007 : U64 = 48i64;
        let Dict.503 : U64 = CallByName Num.51 Dict.497 Dict.1007;
        let Dict.1006 : U64 = 48i64;
        let Dict.1004 : Int1 = CallByName Num.24 Dict.502 Dict.1006;
        if Dict.1004 then
            jump Dict.927 Dict.499 Dict.500 Dict.501 Dict.496 Dict.503 Dict.502;
        else
            let Dict.1003 : U64 = 16i64;
            let Dict.978 : Int1 = CallByName Num.24 Dict.502 Dict.1003;
            if Dict.978 then
                let Dict.1002 : U64 = CallByName Num.70 Dict.500 Dict.499;
                let Dict.504 : U64 = CallByName Num.70 Dict.501 Dict.1002;
                let Dict.979 : {U64, U64, U64} = CallByName Dict.91 Dict.504 Dict.496 Dict.503 Dict.502;
                dec Dict.496;
                ret Dict.979;
            else
                let Dict.977 : U64 = CallByName Num.70 Dict.500 Dict.499;
                let Dict.505 : U64 = CallByName Num.70 Dict.501 Dict.977;
                let Dict.976 : U64 = 16i64;
                let Dict.975 : U64 = CallByName Num.75 Dict.502 Dict.976;
                let Dict.974 : U64 = CallByName Num.51 Dict.975 Dict.503;
                let Dict.929 : U64 = CallByName Dict.98 Dict.496 Dict.974;
                let Dict.973 : U64 = 8i64;
                let Dict.972 : U64 = CallByName Num.75 Dict.502 Dict.973;
                let Dict.931 : U64 = CallByName Num.51 Dict.972 Dict.503;
                let Dict.930 : U64 = CallByName Dict.98 Dict.496 Dict.931;
                dec Dict.496;
                let Dict.928 : {U64, U64, U64} = Struct {Dict.929, Dict.930, Dict.505};
                ret Dict.928;
    in
    inc #Derived_gen.9;
    jump Dict.927 #Derived_gen.6 #Derived_gen.7 #Derived_gen.8 #Derived_gen.9 #Derived_gen.10 #Derived_gen.11;

procedure Dict.91 (#Derived_gen.0, #Derived_gen.1, #Derived_gen.2, #Derived_gen.3):
    joinpoint Dict.980 Dict.506 Dict.507 Dict.508 Dict.509:
        let Dict.1000 : U64 = CallByName Dict.98 Dict.507 Dict.508;
        let Dict.1001 : U64 = CallByName Dict.93;
        let Dict.995 : U64 = CallByName Num.70 Dict.1000 Dict.1001;
        let Dict.999 : U64 = 8i64;
        let Dict.998 : U64 = CallByName Num.51 Dict.508 Dict.999;
        let Dict.997 : U64 = CallByName Dict.98 Dict.507 Dict.998;
        let Dict.996 : U64 = CallByName Num.70 Dict.997 Dict.506;
        let Dict.510 : U64 = CallByName Dict.96 Dict.995 Dict.996;
        let Dict.994 : U64 = 16i64;
        let Dict.511 : U64 = CallByName Num.75 Dict.509 Dict.994;
        let Dict.993 : U64 = 16i64;
        let Dict.512 : U64 = CallByName Num.51 Dict.508 Dict.993;
        let Dict.992 : U64 = 16i64;
        let Dict.982 : Int1 = CallByName Num.23 Dict.511 Dict.992;
        if Dict.982 then
            let Dict.991 : U64 = 16i64;
            let Dict.990 : U64 = CallByName Num.75 Dict.511 Dict.991;
            let Dict.989 : U64 = CallByName Num.51 Dict.990 Dict.512;
            let Dict.984 : U64 = CallByName Dict.98 Dict.507 Dict.989;
            let Dict.988 : U64 = 8i64;
            let Dict.987 : U64 = CallByName Num.75 Dict.511 Dict.988;
            let Dict.986 : U64 = CallByName Num.51 Dict.987 Dict.512;
            let Dict.985 : U64 = CallByName Dict.98 Dict.507 Dict.986;
            dec Dict.507;
            let Dict.983 : {U64, U64, U64} = Struct {Dict.984, Dict.985, Dict.510};
            ret Dict.983;
        else
            jump Dict.980 Dict.510 Dict.507 Dict.512 Dict.511;
    in
    inc #Derived_gen.1;
    jump Dict.980 #Derived_gen.0 #Derived_gen.1 #Derived_gen.2 #Derived_gen.3;

procedure Dict.92 ():
    let Dict.917 : U64 = 11562461410679940143i64;
    ret Dict.917;

procedure Dict.93 ():
    let Dict.913 : U64 = 16646288086500911323i64;
    ret Dict.913;

procedure Dict.94 ():
    let Dict.1026 : U64 = 10285213230658275043i64;
    ret Dict.1026;

procedure Dict.95 ():
    let Dict.1016 : U64 = 6384245875588680899i64;
    ret Dict.1016;

procedure Dict.96 (Dict.513, Dict.514):
    let Dict.905 : {U64, U64} = CallByName Dict.97 Dict.513 Dict.514;
    let Dict.515 : U64 = StructAtIndex 0 Dict.905;
    let Dict.516 : U64 = StructAtIndex 1 Dict.905;
    let Dict.904 : U64 = CallByName Num.70 Dict.515 Dict.516;
    ret Dict.904;

procedure Dict.97 (Dict.517, Dict.518):
    let Dict.909 : U128 = CallByName Num.135 Dict.517;
    let Dict.910 : U128 = CallByName Num.135 Dict.518;
    let Dict.519 : U128 = CallByName Num.78 Dict.909 Dict.910;
    let Dict.520 : U64 = CallByName Num.133 Dict.519;
    let Dict.908 : U8 = 64i64;
    let Dict.907 : U128 = CallByName Num.74 Dict.519 Dict.908;
    let Dict.521 : U64 = CallByName Num.133 Dict.907;
    let Dict.906 : {U64, U64} = Struct {Dict.520, Dict.521};
    ret Dict.906;

procedure Dict.98 (Dict.522, Dict.523):
    let Dict.971 : U8 = CallByName Dict.22 Dict.522 Dict.523;
    let Dict.524 : U64 = CallByName Num.133 Dict.971;
    let Dict.970 : U64 = 1i64;
    let Dict.969 : U64 = CallByName Num.51 Dict.523 Dict.970;
    let Dict.968 : U8 = CallByName Dict.22 Dict.522 Dict.969;
    let Dict.525 : U64 = CallByName Num.133 Dict.968;
    let Dict.967 : U64 = 2i64;
    let Dict.966 : U64 = CallByName Num.51 Dict.523 Dict.967;
    let Dict.965 : U8 = CallByName Dict.22 Dict.522 Dict.966;
    let Dict.526 : U64 = CallByName Num.133 Dict.965;
    let Dict.964 : U64 = 3i64;
    let Dict.963 : U64 = CallByName Num.51 Dict.523 Dict.964;
    let Dict.962 : U8 = CallByName Dict.22 Dict.522 Dict.963;
    let Dict.527 : U64 = CallByName Num.133 Dict.962;
    let Dict.961 : U64 = 4i64;
    let Dict.960 : U64 = CallByName Num.51 Dict.523 Dict.961;
    let Dict.959 : U8 = CallByName Dict.22 Dict.522 Dict.960;
    let Dict.528 : U64 = CallByName Num.133 Dict.959;
    let Dict.958 : U64 = 5i64;
    let Dict.957 : U64 = CallByName Num.51 Dict.523 Dict.958;
    let Dict.956 : U8 = CallByName Dict.22 Dict.522 Dict.957;
    let Dict.529 : U64 = CallByName Num.133 Dict.956;
    let Dict.955 : U64 = 6i64;
    let Dict.954 : U64 = CallByName Num.51 Dict.523 Dict.955;
    let Dict.953 : U8 = CallByName Dict.22 Dict.522 Dict.954;
    let Dict.530 : U64 = CallByName Num.133 Dict.953;
    let Dict.952 : U64 = 7i64;
    let Dict.950 : U64 = CallByName Num.51 Dict.523 Dict.952;
    let Dict.949 : U8 = CallByName Dict.22 Dict.522 Dict.950;
    let Dict.531 : U64 = CallByName Num.133 Dict.949;
    let Dict.948 : U8 = 8i64;
    let Dict.947 : U64 = CallByName Num.72 Dict.525 Dict.948;
    let Dict.532 : U64 = CallByName Num.71 Dict.524 Dict.947;
    let Dict.946 : U8 = 16i64;
    let Dict.943 : U64 = CallByName Num.72 Dict.526 Dict.946;
    let Dict.945 : U8 = 24i64;
    let Dict.944 : U64 = CallByName Num.72 Dict.527 Dict.945;
    let Dict.533 : U64 = CallByName Num.71 Dict.943 Dict.944;
    let Dict.942 : U8 = 32i64;
    let Dict.939 : U64 = CallByName Num.72 Dict.528 Dict.942;
    let Dict.941 : U8 = 40i64;
    let Dict.940 : U64 = CallByName Num.72 Dict.529 Dict.941;
    let Dict.534 : U64 = CallByName Num.71 Dict.939 Dict.940;
    let Dict.938 : U8 = 48i64;
    let Dict.935 : U64 = CallByName Num.72 Dict.530 Dict.938;
    let Dict.937 : U8 = 56i64;
    let Dict.936 : U64 = CallByName Num.72 Dict.531 Dict.937;
    let Dict.535 : U64 = CallByName Num.71 Dict.935 Dict.936;
    let Dict.933 : U64 = CallByName Num.71 Dict.532 Dict.533;
    let Dict.934 : U64 = CallByName Num.71 Dict.534 Dict.535;
    let Dict.932 : U64 = CallByName Num.71 Dict.933 Dict.934;
    ret Dict.932;

procedure Dict.99 (Dict.536, Dict.537):
    let Dict.1083 : U8 = CallByName Dict.22 Dict.536 Dict.537;
    let Dict.538 : U64 = CallByName Num.133 Dict.1083;
    let Dict.1082 : U64 = 1i64;
    let Dict.1081 : U64 = CallByName Num.51 Dict.537 Dict.1082;
    let Dict.1080 : U8 = CallByName Dict.22 Dict.536 Dict.1081;
    let Dict.539 : U64 = CallByName Num.133 Dict.1080;
    let Dict.1079 : U64 = 2i64;
    let Dict.1078 : U64 = CallByName Num.51 Dict.537 Dict.1079;
    let Dict.1077 : U8 = CallByName Dict.22 Dict.536 Dict.1078;
    let Dict.540 : U64 = CallByName Num.133 Dict.1077;
    let Dict.1076 : U64 = 3i64;
    let Dict.1075 : U64 = CallByName Num.51 Dict.537 Dict.1076;
    let Dict.1074 : U8 = CallByName Dict.22 Dict.536 Dict.1075;
    let Dict.541 : U64 = CallByName Num.133 Dict.1074;
    let Dict.1073 : U8 = 8i64;
    let Dict.1072 : U64 = CallByName Num.72 Dict.539 Dict.1073;
    let Dict.542 : U64 = CallByName Num.71 Dict.538 Dict.1072;
    let Dict.1071 : U8 = 16i64;
    let Dict.1068 : U64 = CallByName Num.72 Dict.540 Dict.1071;
    let Dict.1070 : U8 = 24i64;
    let Dict.1069 : U64 = CallByName Num.72 Dict.541 Dict.1070;
    let Dict.543 : U64 = CallByName Num.71 Dict.1068 Dict.1069;
    let Dict.1067 : U64 = CallByName Num.71 Dict.542 Dict.543;
    ret Dict.1067;

procedure Hash.19 (Hash.42, Hash.43):
    let Hash.75 : List U8 = CallByName Str.12 Hash.43;
    let Hash.74 : {U64, U64} = CallByName Dict.89 Hash.42 Hash.75;
    dec Hash.75;
    ret Hash.74;

procedure Inspect.187 (Inspect.188, #Attr.12):
    let Inspect.186 : {} = StructAtIndex 3 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 2 #Attr.12;
    let Inspect.184 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.183 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = StructAtIndex 0 #Attr.12;
    let Inspect.355 : Str = "{";
    let Inspect.328 : Str = CallByName Inspect.63 Inspect.188 Inspect.355;
    dec Inspect.355;
    let Inspect.329 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = Struct {Inspect.183, Inspect.184, Inspect.185, Inspect.186};
    let Inspect.324 : {Str, Int1} = CallByName Inspect.189 Inspect.328 Inspect.329;
    dec Inspect.328;
    let Inspect.325 : {} = Struct {};
    let Inspect.320 : Str = CallByName Inspect.201 Inspect.324;
    let Inspect.321 : Str = "}";
    let Inspect.319 : Str = CallByName Inspect.63 Inspect.320 Inspect.321;
    dec Inspect.321;
    ret Inspect.319;

procedure Inspect.189 (Inspect.190, #Attr.12):
    let Inspect.186 : {} = StructAtIndex 3 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 2 #Attr.12;
    let Inspect.184 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.183 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = StructAtIndex 0 #Attr.12;
    let Inspect.354 : Int1 = CallByName Bool.1;
    inc Inspect.190;
    let Inspect.332 : {Str, Int1} = Struct {Inspect.190, Inspect.354};
    let Inspect.333 : {{}, {}} = Struct {Inspect.185, Inspect.186};
    let Inspect.331 : {Str, Int1} = CallByName Dict.10 Inspect.183 Inspect.332 Inspect.333;
    ret Inspect.331;

procedure Inspect.191 (Inspect.334, Inspect.194, Inspect.195, #Attr.12):
    let Inspect.186 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 0 #Attr.12;
    let Inspect.192 : Str = StructAtIndex 0 Inspect.334;
    let Inspect.193 : Int1 = StructAtIndex 1 Inspect.334;
    joinpoint Inspect.352 Inspect.196:
        let Inspect.349 : Str = CallByName Inspect.47 Inspect.194;
        let Inspect.347 : Str = CallByName Inspect.31 Inspect.349 Inspect.196;
        dec Inspect.349;
        let Inspect.348 : Str = ": ";
        let Inspect.341 : Str = CallByName Inspect.63 Inspect.347 Inspect.348;
        dec Inspect.348;
        let Inspect.342 : {I64, {}} = Struct {Inspect.195, Inspect.186};
        let Inspect.337 : Str = CallByName Inspect.197 Inspect.341 Inspect.342;
        let Inspect.338 : {} = Struct {};
        let Inspect.336 : {Str, Int1} = CallByName Inspect.199 Inspect.337;
        dec Inspect.337;
        ret Inspect.336;
    in
    if Inspect.193 then
        let Inspect.353 : Str = ", ";
        let Inspect.351 : Str = CallByName Inspect.63 Inspect.192 Inspect.353;
        dec Inspect.353;
        jump Inspect.352 Inspect.351;
    else
        jump Inspect.352 Inspect.192;

procedure Inspect.197 (Inspect.198, #Attr.12):
    let Inspect.186 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.195 : I64 = StructAtIndex 0 #Attr.12;
    let Inspect.345 : I64 = CallByName Inspect.57 Inspect.195;
    let Inspect.344 : Str = CallByName Inspect.31 Inspect.345 Inspect.198;
    ret Inspect.344;

procedure Inspect.199 (Inspect.200):
    let Inspect.340 : Int1 = CallByName Bool.2;
    inc Inspect.200;
    let Inspect.339 : {Str, Int1} = Struct {Inspect.200, Inspect.340};
    ret Inspect.339;

procedure Inspect.201 (Inspect.326):
    let Inspect.327 : Str = StructAtIndex 0 Inspect.326;
    ret Inspect.327;

procedure Inspect.250 (Inspect.251, Inspect.249):
    let Inspect.370 : Str = "\"";
    let Inspect.369 : Str = CallByName Inspect.63 Inspect.251 Inspect.370;
    dec Inspect.370;
    let Inspect.367 : Str = CallByName Inspect.63 Inspect.369 Inspect.249;
    let Inspect.368 : Str = "\"";
    let Inspect.366 : Str = CallByName Inspect.63 Inspect.367 Inspect.368;
    dec Inspect.368;
    ret Inspect.366;

procedure Inspect.278 (Inspect.279, Inspect.277):
    let Inspect.361 : Str = CallByName Num.96 Inspect.277;
    let Inspect.360 : Str = CallByName Inspect.63 Inspect.279 Inspect.361;
    dec Inspect.361;
    ret Inspect.360;

procedure Inspect.30 (Inspect.147):
    ret Inspect.147;

procedure Inspect.30 (Inspect.147):
    ret Inspect.147;

procedure Inspect.30 (Inspect.147):
    ret Inspect.147;

procedure Inspect.30 (Inspect.147):
    ret Inspect.147;

procedure Inspect.31 (Inspect.303, Inspect.149):
    let Inspect.314 : Str = CallByName Inspect.187 Inspect.149 Inspect.303;
    ret Inspect.314;

procedure Inspect.31 (Inspect.303, Inspect.149):
    let Inspect.346 : Str = CallByName Inspect.278 Inspect.149 Inspect.303;
    ret Inspect.346;

procedure Inspect.31 (Inspect.303, Inspect.149):
    let Inspect.350 : Str = CallByName Inspect.250 Inspect.149 Inspect.303;
    ret Inspect.350;

procedure Inspect.33 (Inspect.152):
    let Inspect.305 : Str = CallByName Inspect.5 Inspect.152;
    let Inspect.304 : Str = CallByName Inspect.64 Inspect.305;
    ret Inspect.304;

procedure Inspect.39 (Inspect.301):
    let Inspect.311 : Str = "";
    ret Inspect.311;

procedure Inspect.42 (Inspect.183, Inspect.184, Inspect.185, Inspect.186):
    let Inspect.316 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = Struct {Inspect.183, Inspect.184, Inspect.185, Inspect.186};
    let Inspect.315 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = CallByName Inspect.30 Inspect.316;
    ret Inspect.315;

procedure Inspect.47 (Inspect.249):
    let Inspect.362 : Str = CallByName Inspect.30 Inspect.249;
    ret Inspect.362;

procedure Inspect.5 (Inspect.150):
    let Inspect.312 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.43 Inspect.150;
    let Inspect.309 : {} = Struct {};
    let Inspect.308 : Str = CallByName Inspect.39 Inspect.309;
    let Inspect.307 : Str = CallByName Dict.127 Inspect.308 Inspect.312;
    ret Inspect.307;

procedure Inspect.57 (Inspect.277):
    let Inspect.356 : I64 = CallByName Inspect.30 Inspect.277;
    ret Inspect.356;

procedure Inspect.63 (Inspect.300, Inspect.296):
    let Inspect.323 : Str = CallByName Str.3 Inspect.300 Inspect.296;
    ret Inspect.323;

procedure Inspect.64 (Inspect.302):
    ret Inspect.302;

procedure List.11 (List.144, List.145):
    let List.687 : List {U32, U32} = CallByName List.68 List.145;
    let List.686 : List {U32, U32} = CallByName List.93 List.144 List.145 List.687;
    ret List.686;

procedure List.18 (List.166, List.167, List.168):
    let List.626 : U64 = 0i64;
    let List.627 : U64 = CallByName List.6 List.166;
    let List.625 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName List.95 List.166 List.167 List.168 List.626 List.627;
    ret List.625;

procedure List.18 (List.166, List.167, List.168):
    let List.690 : U64 = 0i64;
    let List.691 : U64 = CallByName List.6 List.166;
    let List.689 : {Str, Int1} = CallByName List.95 List.166 List.167 List.168 List.690 List.691;
    ret List.689;

procedure List.3 (List.122, List.123, List.124):
    let List.651 : {List {U32, U32}, {U32, U32}} = CallByName List.64 List.122 List.123 List.124;
    let List.650 : List {U32, U32} = StructAtIndex 0 List.651;
    ret List.650;

procedure List.3 (List.122, List.123, List.124):
    let List.653 : {List {Str, I64}, {Str, I64}} = CallByName List.64 List.122 List.123 List.124;
    let List.652 : List {Str, I64} = StructAtIndex 0 List.653;
    let #Derived_gen.71 : {Str, I64} = StructAtIndex 1 List.653;
    dec #Derived_gen.71;
    ret List.652;

procedure List.4 (List.130, List.131):
    let List.662 : U64 = 1i64;
    let List.660 : List {Str, I64} = CallByName List.70 List.130 List.662;
    let List.659 : List {Str, I64} = CallByName List.71 List.660 List.131;
    ret List.659;

procedure List.6 (#Attr.2):
    let List.641 : U64 = lowlevel ListLenU64 #Attr.2;
    ret List.641;

procedure List.6 (#Attr.2):
    let List.688 : U64 = lowlevel ListLenU64 #Attr.2;
    ret List.688;

procedure List.6 (#Attr.2):
    let List.700 : U64 = lowlevel ListLenU64 #Attr.2;
    ret List.700;

procedure List.64 (List.119, List.120, List.121):
    let List.649 : U64 = CallByName List.6 List.119;
    let List.646 : Int1 = CallByName Num.22 List.120 List.649;
    if List.646 then
        let List.647 : {List {U32, U32}, {U32, U32}} = CallByName List.67 List.119 List.120 List.121;
        ret List.647;
    else
        let List.645 : {List {U32, U32}, {U32, U32}} = Struct {List.119, List.121};
        ret List.645;

procedure List.64 (List.119, List.120, List.121):
    let List.658 : U64 = CallByName List.6 List.119;
    let List.655 : Int1 = CallByName Num.22 List.120 List.658;
    if List.655 then
        let List.656 : {List {Str, I64}, {Str, I64}} = CallByName List.67 List.119 List.120 List.121;
        ret List.656;
    else
        let List.654 : {List {Str, I64}, {Str, I64}} = Struct {List.119, List.121};
        ret List.654;

procedure List.66 (#Attr.2, #Attr.3):
    let List.699 : {Str, I64} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.699;

procedure List.67 (#Attr.2, #Attr.3, #Attr.4):
    let List.648 : {List {U32, U32}, {U32, U32}} = lowlevel ListReplaceUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret List.648;

procedure List.67 (#Attr.2, #Attr.3, #Attr.4):
    let List.657 : {List {Str, I64}, {Str, I64}} = lowlevel ListReplaceUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret List.657;

procedure List.68 (#Attr.2):
    let List.685 : List {U32, U32} = lowlevel ListWithCapacity #Attr.2;
    ret List.685;

procedure List.70 (#Attr.2, #Attr.3):
    let List.663 : List {Str, I64} = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.663;

procedure List.71 (#Attr.2, #Attr.3):
    let List.661 : List {Str, I64} = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.661;

procedure List.71 (#Attr.2, #Attr.3):
    let List.682 : List {U32, U32} = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.682;

procedure List.83 (List.175, List.176, List.177):
    let List.665 : U64 = 0i64;
    let List.666 : U64 = CallByName List.6 List.175;
    let List.664 : List {U32, U32} = CallByName List.96 List.175 List.176 List.177 List.665 List.666;
    ret List.664;

procedure List.93 (#Derived_gen.63, #Derived_gen.64, #Derived_gen.65):
    joinpoint List.676 List.146 List.147 List.148:
        let List.684 : U64 = 0i64;
        let List.678 : Int1 = CallByName Num.24 List.147 List.684;
        if List.678 then
            let List.683 : U64 = 1i64;
            let List.680 : U64 = CallByName Num.75 List.147 List.683;
            let List.681 : List {U32, U32} = CallByName List.71 List.148 List.146;
            jump List.676 List.146 List.680 List.681;
        else
            ret List.148;
    in
    jump List.676 #Derived_gen.63 #Derived_gen.64 #Derived_gen.65;

procedure List.95 (#Derived_gen.23, #Derived_gen.24, #Derived_gen.25, #Derived_gen.26, #Derived_gen.27):
    joinpoint List.692 List.169 List.170 List.171 List.172 List.173:
        let List.694 : Int1 = CallByName Num.22 List.172 List.173;
        if List.694 then
            let List.698 : {Str, I64} = CallByName List.66 List.169 List.172;
            inc List.698;
            let List.174 : {Str, Int1} = CallByName Dict.188 List.170 List.698 List.171;
            let List.697 : U64 = 1i64;
            let List.696 : U64 = CallByName Num.51 List.172 List.697;
            jump List.692 List.169 List.174 List.171 List.696 List.173;
        else
            dec List.169;
            ret List.170;
    in
    inc #Derived_gen.23;
    jump List.692 #Derived_gen.23 #Derived_gen.24 #Derived_gen.25 #Derived_gen.26 #Derived_gen.27;

procedure List.95 (#Derived_gen.37, #Derived_gen.38, #Derived_gen.39, #Derived_gen.40, #Derived_gen.41):
    joinpoint List.628 List.169 List.170 List.171 List.172 List.173:
        let List.630 : Int1 = CallByName Num.22 List.172 List.173;
        if List.630 then
            let List.634 : {Str, I64} = CallByName List.66 List.169 List.172;
            inc List.634;
            let List.174 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.159 List.170 List.634;
            let List.633 : U64 = 1i64;
            let List.632 : U64 = CallByName Num.51 List.172 List.633;
            jump List.628 List.169 List.174 List.171 List.632 List.173;
        else
            dec List.169;
            ret List.170;
    in
    inc #Derived_gen.37;
    jump List.628 #Derived_gen.37 #Derived_gen.38 #Derived_gen.39 #Derived_gen.40 #Derived_gen.41;

procedure List.96 (#Derived_gen.56, #Derived_gen.57, #Derived_gen.58, #Derived_gen.59, #Derived_gen.60):
    joinpoint List.667 List.178 List.179 List.180 List.181 List.182:
        let List.669 : Int1 = CallByName Num.22 List.181 List.182;
        if List.669 then
            let List.673 : {Str, I64} = CallByName List.66 List.178 List.181;
            inc List.673;
            let List.183 : List {U32, U32} = CallByName Dict.405 List.179 List.673 List.181 List.180;
            let List.672 : U64 = 1i64;
            let List.671 : U64 = CallByName Num.51 List.181 List.672;
            jump List.667 List.178 List.183 List.180 List.671 List.182;
        else
            dec List.178;
            ret List.179;
    in
    inc #Derived_gen.56;
    jump List.667 #Derived_gen.56 #Derived_gen.57 #Derived_gen.58 #Derived_gen.59 #Derived_gen.60;

procedure Num.131 (#Attr.2):
    let Num.289 : U32 = lowlevel NumIntCast #Attr.2;
    ret Num.289;

procedure Num.133 (#Attr.2):
    let Num.297 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.297;

procedure Num.133 (#Attr.2):
    let Num.346 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.346;

procedure Num.133 (#Attr.2):
    let Num.361 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.361;

procedure Num.135 (#Attr.2):
    let Num.367 : U128 = lowlevel NumIntCast #Attr.2;
    ret Num.367;

procedure Num.139 (#Attr.2):
    let Num.315 : Float32 = lowlevel NumToFloatCast #Attr.2;
    ret Num.315;

procedure Num.148 (Num.225, Num.226):
    let Num.317 : Int1 = CallByName Num.22 Num.225 Num.226;
    if Num.317 then
        ret Num.225;
    else
        ret Num.226;

procedure Num.21 (#Attr.2, #Attr.3):
    let Num.314 : Float32 = lowlevel NumMul #Attr.2 #Attr.3;
    ret Num.314;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.311 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.311;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.440 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.440;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.433 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.433;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.295 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.295;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.436 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.436;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.437 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.437;

procedure Num.50 (#Attr.2):
    let Num.313 : U64 = lowlevel NumFloor #Attr.2;
    ret Num.313;

procedure Num.51 (#Attr.2, #Attr.3):
    let Num.281 : U32 = lowlevel NumAddWrap #Attr.2 #Attr.3;
    ret Num.281;

procedure Num.51 (#Attr.2, #Attr.3):
    let Num.439 : U64 = lowlevel NumAddWrap #Attr.2 #Attr.3;
    ret Num.439;

procedure Num.69 (#Attr.2, #Attr.3):
    let Num.303 : U32 = lowlevel NumBitwiseAnd #Attr.2 #Attr.3;
    ret Num.303;

procedure Num.70 (#Attr.2, #Attr.3):
    let Num.344 : U64 = lowlevel NumBitwiseXor #Attr.2 #Attr.3;
    ret Num.344;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.302 : U32 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.302;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.381 : U64 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.381;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.284 : U32 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.284;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.396 : U64 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.396;

procedure Num.74 (#Attr.2, #Attr.3):
    let Num.362 : U128 = lowlevel NumShiftRightZfBy #Attr.2 #Attr.3;
    ret Num.362;

procedure Num.74 (#Attr.2, #Attr.3):
    let Num.364 : U64 = lowlevel NumShiftRightZfBy #Attr.2 #Attr.3;
    ret Num.364;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.291 : U32 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.291;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.294 : U8 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.294;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.430 : U64 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.430;

procedure Num.78 (#Attr.2, #Attr.3):
    let Num.365 : U128 = lowlevel NumMulWrap #Attr.2 #Attr.3;
    ret Num.365;

procedure Num.96 (#Attr.2):
    let Num.310 : Str = lowlevel NumToStr #Attr.2;
    ret Num.310;

procedure Num.96 (#Attr.2):
    let Num.438 : Str = lowlevel NumToStr #Attr.2;
    ret Num.438;

procedure Str.12 (#Attr.2):
    let Str.238 : List U8 = lowlevel StrToUtf8 #Attr.2;
    ret Str.238;

procedure Str.3 (#Attr.2, #Attr.3):
    let Str.239 : Str = lowlevel StrConcat #Attr.2 #Attr.3;
    ret Str.239;

procedure Test.0 ():
    let Test.8 : Str = "a";
    let Test.9 : I64 = 1i64;
    let Test.4 : {Str, I64} = Struct {Test.8, Test.9};
    let Test.6 : Str = "b";
    let Test.7 : I64 = 2i64;
    let Test.5 : {Str, I64} = Struct {Test.6, Test.7};
    let Test.3 : List {Str, I64} = Array [Test.4, Test.5];
    let Test.2 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.12 Test.3;
    dec Test.3;
    let Test.1 : Str = CallByName Inspect.33 Test.2;
    ret Test.1;
